diff --git a/gson/src/test/java/com/google/gson/HandleRawEnumTest.java b/gson/src/test/java/com/google/gson/HandleRawEnumTest.java
new file mode 100644
index 00000000..0882d176
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/HandleRawEnumTest.java
@@ -0,0 +1,96 @@
+package com.google.gson.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Test processing raw enum types.
+ *
+ * @author sevcenko
+ */
+public class HandleRawEnumTest {
+  private Gson gson;
+
+  @Before
+  public void setUp() throws Exception {
+    gson = new Gson();
+  }
+
+  public enum SomeEnum {
+    ONE
+  }
+
+  public static class ClassWithRawEnum {
+    private final Enum<?> anyEnum;
+
+    public ClassWithRawEnum(Enum<?> anyEnum) {
+      this.anyEnum = anyEnum;
+    }
+
+    public Enum<?> getAnyEnum() {
+      return anyEnum;
+    }
+  }
+
+  public static class ClassWithTypedEnum<T extends Enum<T>> {
+    private final T someEnum;
+
+    public ClassWithTypedEnum(T someEnum) {
+      this.someEnum = someEnum;
+    }
+
+    public T getSomeEnum() {
+      return someEnum;
+    }
+  }
+
+  public static class GroupClass {
+
+    private final ClassWithTypedEnum<SomeEnum> field;
+
+    public GroupClass(ClassWithTypedEnum<SomeEnum> field) {
+      this.field = field;
+    }
+
+    public ClassWithTypedEnum<SomeEnum> getField() {
+      return field;
+    }
+  }
+
+  @Test
+  public void handleRawEnumClass() {
+    // serializing raw enum is fine, but note that Adapters.ENUM_FACTORY cannot handle raw enums
+    // even for serialization! before #2563, this just failed because raw enum falled through
+    // ReflectiveTypeAdapterFactory, which fails to even search enum for fields
+    assertThat(gson.toJson(new ClassWithRawEnum(SomeEnum.ONE))).isEqualTo("{\"anyEnum\":\"ONE\"}");
+
+    // we can deserialize if the enum type is known
+    assertThat(
+            gson.fromJson(
+                    "{\"someEnum\":\"ONE\"}", new TypeToken<ClassWithTypedEnum<SomeEnum>>() {})
+                .getSomeEnum())
+        .isEqualTo(SomeEnum.ONE);
+
+    assertThat(gson.toJson(new GroupClass(new ClassWithTypedEnum<>(SomeEnum.ONE))))
+        .isEqualTo("{\"field\":{\"someEnum\":\"ONE\"}}");
+
+    assertThat(
+            gson.fromJson("{\"field\":{\"someEnum\":\"ONE\"}}", GroupClass.class)
+                .getField()
+                .getSomeEnum())
+        .isEqualTo(SomeEnum.ONE);
+    ;
+    try {
+      //       but raw type cannot be deserialized
+      gson.fromJson("{\"anyEnum\":\"ONE\"}", new TypeToken<ClassWithRawEnum>() {});
+      fail("Expected exception");
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageThat().contains("Can not set final java.lang.Enum field");
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/functional/InferenceFromTypeVariableTest.java b/gson/src/test/java/com/google/gson/functional/InferenceFromTypeVariableTest.java
new file mode 100644
index 00000000..490da5a2
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/InferenceFromTypeVariableTest.java
@@ -0,0 +1,77 @@
+package com.google.gson.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Test deserialization of generic wrapper with type bound.
+ *
+ * @author sevcenko
+ */
+public class InferenceFromTypeVariableTest {
+  private Gson gson;
+
+  @Before
+  public void setUp() throws Exception {
+    gson = new GsonBuilder().registerTypeAdapterFactory(new ResolveGenericBoundFactory()).create();
+  }
+
+  public static class Foo {
+    private final String text;
+
+    public Foo(String text) {
+      this.text = text;
+    }
+
+    public String getText() {
+      return text;
+    }
+  }
+
+  public static class BarDynamic<T extends Foo> {
+    private final T foo;
+
+    public BarDynamic(T foo) {
+      this.foo = foo;
+    }
+
+    public T getFoo() {
+      return foo;
+    }
+  }
+
+  static class ResolveGenericBoundFactory implements TypeAdapterFactory {
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+      if (type.getType() instanceof TypeVariable<?>) {
+        TypeVariable<?> tv = (TypeVariable<?>) type.getType();
+        Type[] bounds = tv.getBounds();
+        if (bounds.length == 1 && bounds[0] != Object.class) {
+          Type bound = bounds[0];
+          return (TypeAdapter<T>) gson.getAdapter(TypeToken.get(bound));
+        }
+      }
+      return null;
+    }
+  }
+
+  @Test
+  public void testSubClassSerialization() {
+    BarDynamic<Foo> bar = new BarDynamic<>(new Foo("foo!"));
+    assertThat(gson.toJson(bar)).isEqualTo("{\"foo\":{\"text\":\"foo!\"}}");
+    // without #2563 fix, this would deserialize foo as Object and fails to assign it to foo field
+    BarDynamic<?> deserialized = gson.fromJson(gson.toJson(bar), BarDynamic.class);
+    assertThat(deserialized.getFoo().getText()).isEqualTo("foo!");
+  }
+}
